<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="data:,">
    <title>Social Impression Rating Task</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-instructions@1.1.4"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        
        .rating-container {
            text-align: center;
            margin-top: 30px;
        }
        
        .rating-scale {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 20px auto;
            max-width: 700px;
        }
        
        .rating-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 10px;
        }
        
        .rating-number {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .rating-label {
            font-size: 14px;
            text-align: center;
            max-width: 80px;
        }
        
        .question-text {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .slider-container {
            margin: 30px auto;
            max-width: 600px;
            text-align: center;
        }
        
        .slider-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }
        
        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 14px;
        }
        
        .slider {
            width: 500px;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            outline: none;
            border-radius: 5px;
            margin: 0 20px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
        }
        
        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .slider-value {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
            min-width: 30px;
        }
        
        .warning-message {
            color: red;
            font-size: 18px;
            font-weight: bold;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }
        
        .validation-warning {
            color: red;
            font-size: 18px;
            font-weight: bold;
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }
        
        .stimulus-image {
            max-width: 180px;
            max-height: 220px;
            object-fit: contain;
            display: block;
            margin: 20px auto;
        }
        
        .bio-text {
            max-width: 800px;
            margin: 20px auto;
            text-align: left;
            font-size: 16px;
            line-height: 1.6;
            padding: 20px;
            background-color: #f5f5f5;
            border-radius: 8px;
        }
        
        .dual-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .attention-check {
            font-size: 20px;
            margin: 40px auto;
            max-width: 600px;
            text-align: center;
            padding: 30px;
            background-color: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
        }
        
        .fixation {
            font-size: 60px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        .stimulus-with-rating {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        
        .rating-option.selected {
            background-color: #4CAF50;
            border-radius: 5px;
            padding: 5px;
        }
        
        .rating-option.selected .rating-number {
            color: white;
        }
        
        .submit-prompt {
            margin-top: 20px;
            font-size: 16px;
            font-style: italic;
            color: #666;
        }
        
        .candidate-name {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        
        .familiarity-buttons {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px 0;
        }
        
        .familiarity-button {
            padding: 15px 40px;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #4CAF50;
            background-color: white;
            color: #4CAF50;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .familiarity-button:hover {
            background-color: #e8f5e9;
        }
        
        .familiarity-button.selected {
            background-color: #4CAF50;
            color: white;
        }
        
        .response-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 18px;
            font-weight: bold;
            color: black;
            z-index: 1000;
        }
        
        .free-writing-container {
            max-width: 800px;
            margin: 50px auto;
            padding: 30px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        
        .rating-display {
            font-size: 18px;
            margin: 20px 0;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 5px;
            text-align: center;
        }
        
        .free-writing-prompt {
            font-size: 18px;
            font-weight: bold;
            margin: 30px 0 15px 0;
        }
        
        .free-writing-textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            font-size: 16px;
            font-family: Arial, sans-serif;
            border: 2px solid #ccc;
            border-radius: 5px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .free-writing-textarea:focus {
            outline: none;
            border-color: #4CAF50;
        }
    </style>
</head>
<body></body>
<script>

    // ===== EXPERIMENT VERSION =====
    const EXPERIMENT_VERSION = '31';
    console.log('====================================');
    console.log('Experiment Version:', EXPERIMENT_VERSION);
    console.log('====================================');
    // ==============================

    // ===== TEST MODE =====
    // Set to true to enable faster testing (0ms stimulus presentation + 5 candidates only)
    const TEST_MODE = false;
    // =====================

    // Initialize jsPsych
    const jsPsych = initJsPsych({
        on_finish: function() {
            // Add assigned trial type, participant ID, start time, SONA code, and version to all data rows
            jsPsych.data.get().addToAll({
                assigned_group: assignedGroup,
                assigned_trial_type: assignedTrialType,
                participant_id: participantID,
                experiment_start_time: experimentStartTime,
                sona_survey_code: sonaSurveyCode,
                experiment_version: EXPERIMENT_VERSION
            });
            
            // Get all data as JSON for PHP backend
            const allData = jsPsych.data.get().values();
            // Ensure all rows contain the primary expected keys (so CSV headers include them even if first row lacks them)
            const requiredFields = [
                'assigned_group', 'assigned_trial_type', 'participant_id', 'experiment_start_time', 'sona_survey_code', 'experiment_version',
                'task', 'block', 'stimulus_name', 'stimulus_trial_type', 'competence_response', 'vote_response',
                'familiarity_response', 'confidence_response', 'responded_on_time', 'reaction_time_ms', 'response_time_limit_ms',
                'attention_check_question', 'attention_check_correct_key', 'attention_check_response',
                'memory_check_question', 'memory_check_correct_answer', 'memory_check_response', 'memory_check_correct',
                'free_response'
            ];
            for (let row of allData) {
                for (let f of requiredFields) {
                    if (!(f in row)) {
                        row[f] = null;
                    }
                }
            }
            // Debug: Log data summary keys to verify fields present (e.g., rating)
            try {
                if (allData && allData.length) {
                    console.log('Total rows to send:', allData.length);
                    // Show the keys present in the last row and a sample of a rating row
                    const allKeys = Object.keys(allData[allData.length - 1]);
                    console.log('Keys in last data row:', allKeys);
                    const sampleRatingRow = [...allData].reverse().find(r => 'competence_response' in r || 'vote_response' in r || 'familiarity_response' in r);
                    if (sampleRatingRow) {
                        console.log('Sample rating row found:', sampleRatingRow);
                    } else {
                        console.warn('No rating rows with competence_response/vote_response/familiarity_response were found in data');
                    }
                } else {
                    console.warn('No data rows to send.');
                }
                } catch (e) {
                console.error('Error while inspecting data before sending:', e);
            }
            // Show a per-row presence/value for competence and vote responses
            try {
                const responsePresence = allData.map((r, i) => ({index: i, competence: r.competence_response, vote: r.vote_response}));
                console.log('competence/vote response presence per row (first 30 rows):', JSON.stringify(responsePresence.slice(0, 30)));
            } catch (e) {
                console.warn('Could not compute response presence list:', e);
            }
            
            // Send data to PHP backend
            const saveDataURL = 'save_data.php';
            console.log('Sending data to PHP backend...', allData.length, 'rows');
            // Additional diagnostics of the payload we are about to send
            try {
                const ratingRows = allData.filter(r => r.task === 'rating');
                const withCompetence = ratingRows.filter(r => r.competence_response !== null && r.competence_response !== undefined && r.competence_response !== '');
                const withVote = ratingRows.filter(r => r.vote_response !== null && r.vote_response !== undefined && r.vote_response !== '');
                console.log('Rating rows (task=="rating"):', ratingRows.length);
                console.log('Rating rows with non-empty competence_response:', withCompetence.length);
                console.log('Rating rows with non-empty vote_response:', withVote.length);
                if (withCompetence.length > 0) console.log('Example competence rating row:', JSON.stringify(withCompetence[0]));
                if (withVote.length > 0) console.log('Example vote rating row:', JSON.stringify(withVote[0]));
                // Print a small payload sample (first 5 rows) so we can see exactly which keys are present
                const payloadSample = allData.slice(0, 5).map(r => {
                    const copy = {};
                    Object.keys(r).forEach(k => { copy[k] = r[k]; });
                    return copy;
                });
                console.log('Payload sample (first 5 rows):', JSON.stringify(payloadSample));
            } catch (e) {
                console.error('Error during payload diagnostics:', e);
            }
            
            // Use fetch with proper handling
            try {
                const jsonString = JSON.stringify(allData);
                console.log('Outgoing JSON payload length:', jsonString.length);
                // Also show the first 1000 chars so dev console shows content at a glance
                console.log('Outgoing JSON payload start:', jsonString.slice(0, 1000));
            } catch (e) {
                console.warn('Could not stringify entire payload:', e);
            }
            fetch(saveDataURL, {
                method: 'POST',
                body: JSON.stringify(allData),
                headers: {
                    'Content-Type': 'application/json',
                }
            }).then(function(response) {
                console.log('PHP backend response status:', response.status);
                return response.json();
            }).then(function(result) {
                console.log('PHP backend response:', result);
                
                if (!result.success) {
                    throw new Error(result.error || 'Unknown error from server');
                }
                
                console.log('Data saved successfully:', result.filename, '(' + result.rows + ' rows)');
                
                // Redirect to SONA for credit if we have a valid survey code
                if (sonaSurveyCode && sonaSurveyCode !== 'NO_SONA_CODE') {
                    console.log('Redirecting to SONA for credit...');
                    const sonaRedirectUrl = SONA_COMPLETION_URL + sonaSurveyCode;
                    // Show brief message before redirect
                    alert('Thank you for completing the experiment! You will now be redirected to SONA to receive credit.');
                    window.location.href = sonaRedirectUrl;
                } else {
                    // No SONA code - regular completion
                    alert('Thank you for completing the experiment! Your data has been saved.');
                }
            }).catch(function(error) {
                console.error('Error sending data to PHP backend:', error);
                
                // Even if data save failed, try to give SONA credit
                if (sonaSurveyCode && sonaSurveyCode !== 'NO_SONA_CODE') {
                    const proceed = confirm('Warning: There was an error saving your data. Do you want to continue to SONA for credit? (Click OK to continue, Cancel to stay on this page)');
                    if (proceed) {
                        const sonaRedirectUrl = SONA_COMPLETION_URL + sonaSurveyCode;
                        window.location.href = sonaRedirectUrl;
                    }
                } else {
                    alert('Warning: There was an error saving your data. Please contact the researcher.');
                }
            });
        }
    });

    // Timeline
    let timeline = [];
    
    // ===== SONA INTEGRATION =====
    // Extract SONA survey code from URL parameter (e.g., ?id=100179)
    const urlParams = new URLSearchParams(window.location.search);
    const sonaSurveyCode = urlParams.get('id') || 'NO_SONA_CODE';
    console.log('SONA Survey Code:', sonaSurveyCode);
    
    // SONA completion URL - Configured for UCSB SONA system
    // Format: https://ucsb.sona-systems.com/webstudy_credit.aspx?experiment_id=XXXX&credit_token=YYYY&survey_code=%SURVEY_CODE%
    // The survey code will be appended automatically from the URL parameter
    const SONA_COMPLETION_URL = 'https://ucsb.sona-systems.com/webstudy_credit.aspx?experiment_id=4708&credit_token=3f94872037f940acbbe8bb7a6325cd81&survey_code=';
    // ============================
    
    // Generate unique participant ID
    const participantID = 'P' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    console.log('Participant ID:', participantID);
    
    // Record experiment start time (human readable)
    const experimentStartTime = new Date().toLocaleString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });
    console.log('Experiment start time:', experimentStartTime);
    
    // Track familiar candidates to exclude from later blocks
    let familiarCandidates = [];
    
    // Track which trials have been used for memory checks in each block
    let memoryCheckUsed = {
        block1: new Set(),
        block2: new Set()
    };
    
    // Track ratings for each candidate for free writing component
    let candidateRatings = {
        block1: {},
        block2: {}
    };

    // Define the questions for the two blocks
    const questions = [
        {
            text: "How good do you think this person would be as a member of congress?",
            scale_labels: ["Not at all", "Very much"],
            confidenceQuestion: {
                text: "How confident are you in your judgment?",
                scale_labels: ["Not at all", "Very much"]
            },
            secondaryQuestion: null  // No similarity question in block 1
        },
        {
            text: "In general, how likely would you be to vote for this person as a U.S. House Representative?",
            scale_labels: ["Not at all", "Very much"],
            confidenceQuestion: null,  // No confidence question in block 2
            secondaryQuestion: null  // Similarity question removed from block 2
        }
    ];

    // Randomly assign participant to one of five groups
    const assignedGroup = Math.floor(Math.random() * 5) + 1; // 1, 2, 3, 4, or 5
    
    // Randomly assign participant to one of three trial type conditions
    const assignedTrialType = Math.floor(Math.random() * 3) + 1; // 1, 2, or 3
    
    console.log('====================================');
    console.log('Assigned Participant Group:', assignedGroup);
    console.log('Assigned Trial Type Condition:', assignedTrialType);
    console.log('====================================');
    
    // Load CSV data and parse it
    let stimuli = [];
    let materialsLoaded = false;
    
    // Function to parse CSV (handles quoted fields with commas)
    function parseCSV(text) {
        // Remove BOM if present
        if (text.charCodeAt(0) === 0xFEFF) {
            text = text.slice(1);
        }
        // Split by \r\n or \n to handle both Windows and Unix line endings
        const lines = text.trim().split(/\r?\n/);
        const headers = parseCSVLine(lines[0]);
        const data = [];
        
        console.log('CSV Headers:', headers);
        
        for (let i = 1; i < lines.length; i++) {
            const values = parseCSVLine(lines[i]);
            const row = {};
            for (let j = 0; j < headers.length; j++) {
                row[headers[j]] = values[j] ? values[j].trim() : '';
            }
            data.push(row);
        }
        return data;
    }
    
    // Function to parse a single CSV line (handles quoted fields)
    function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        result.push(current); // Add the last field
        
        return result;
    }
    
    // Function to load materials from CSV
    async function loadMaterials() {
        try {
            // Add cache-busting parameter to ensure fresh CSV load
            const response = await fetch('materials.csv?v=' + Date.now());
            const text = await response.text();
            const data = parseCSV(text);
            
            const trialTypeColumn = 'trial_type' + assignedTrialType;
            
            for (let row of data) {
                // Skip if exclude flag is set
                if (row.exclude === '1') continue;
                
                // Skip if not in assigned participant group
                if (row.participant_group && row.participant_group !== String(assignedGroup)) continue;
                
                // Skip if no trial type assigned for this condition
                if (!row[trialTypeColumn]) continue;
                
                const imagePath = row.image_name;
                const bioPath = row.bio_name;
                const trialType = row[trialTypeColumn];
                const name = imagePath.replace('image/', '').replace(/\.(jpeg|jpg|png)/, '');
                
                stimuli.push({
                    image: imagePath,
                    bio: bioPath,
                    type: trialType,
                    name: name,
                    check_question: row.check_question,
                    check_answer: row.check_answer
                });
                
                // Log stimuli with memory check questions to verify parsing
                if (row.check_question && row.check_question.length > 0) {
                    console.log('Loaded memory check for', name, '- Question:', row.check_question, '- Correct answer:', row.check_answer, '- Type:', typeof row.check_answer, '- All row keys:', Object.keys(row));
                }
            }
            
            console.log('Loaded', stimuli.length, 'stimuli for Group', assignedGroup, 'Trial Type', assignedTrialType);
            console.log('Stimuli breakdown by type:', {
                photo: stimuli.filter(s => s.type === 'photo').length,
                bio: stimuli.filter(s => s.type === 'bio').length,
                dual: stimuli.filter(s => s.type === 'dual').length
            });
            
            // TEST MODE: Limit to 5 random candidates for faster testing
            if (TEST_MODE && stimuli.length > 5) {
                stimuli = jsPsych.randomization.sampleWithoutReplacement(stimuli, 5);
                console.log('TEST_MODE: Limited to', stimuli.length, 'stimuli for testing');
            }
            
            materialsLoaded = true;
        } catch (error) {
            console.error('Error loading materials:', error);
        }
    }

    // Preload all images and bio files
    const images_to_preload = stimuli.map(s => s.image);
    
    // Object to store loaded bio texts
    const loadedBios = {};
    
    // Preload bio texts
    async function preloadBios() {
        for (let stim of stimuli) {
            if (stim.type === 'bio' || stim.type === 'dual') {
                loadedBios[stim.name] = await loadBioText(stim.bio);
            }
        }
    }
    
    const preload = {
        type: jsPsychPreload,
        images: images_to_preload
    };
    timeline.push(preload);

    // Welcome screen
    const welcome = {
        type: jsPsychInstructions,
        pages: [
            '<h2>Welcome to the Social Impression Rating Task</h2>' +
            '<p>In this experiment, you will see photos and/or biographies of candidate in the election for the U.S. House of Representatives.</p>' +
            '<p>Your task is to rate your impression of each person on different dimensions.</p>' +
            '<p></p>' +
            '<p><b>Before you begin, please ensure:</b></p>' +
            '<ul style="text-align: left; max-width: 500px; margin: 20px auto;">' +
            '<li>You are in a <b>quiet space</b> where you can focus without distractions</li>' +
            '<li>You are using a <b>computer</b> (not a mobile device or tablet)</li>' +
            '<li>You are using a <b>compatible browser</b> (Chrome, Safari, Firefox, or Edge recommended)</li>' +
            '<p>If you have any questions, please contact the researcher at psych-yeslab.study@ucsb.edu.</p>' +
            '</ul>' +
            '<p>Press the Next button to continue.</p>'
        ],
        show_clickable_nav: true
    };
    timeline.push(welcome);
    
    // Consent screen
    const consent = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '<div style="max-width: 800px; margin: 50px auto; text-align: left; padding: 0 20px;">' +
            '<h2 style="text-align: center;">Consent for Participation in a Research Project</h2>' +
            '<p><b>Title:</b> Social perception study<br>' +
            '<b>Investigator:</b> Hongbo Yu, Ph.D., University of California Santa Barbara, Department of Psychological and Brain Sciences, Santa Barbara, CA 93106<br>' +
            '<b>Protocol Number:</b> 2-24-0611</p>' +
            '<p><b>Purpose:</b> You are invited to take part in a research study designed to look at how people make social judgments and decisions. You are being asked to participate in this study because we are interested in these processes in a wide variety of people. The purpose of this study is to advance our understanding of how individual differences in cognitive functioning contribute to social behavior.</p>' +
            '<p><b>Procedures:</b> If you agree to participate, you will see some human face pictures and be asked some questions about them. You may withdraw from this study at any point by closing out of the browser window. Your participation will last about 10 minutes and you will be granted 1 credit/hour for your participation in this study.</p>' +
            '<p><b>Risks and Benefits:</b> There are no known or anticipated risks associated with this study. Although this study will not benefit you personally, we hope that our results will add to the knowledge about how people make decisions about positive and negative outcomes for themselves and for other people.</p>' +
            '<p><b>Confidentiality:</b> All of your responses will be anonymous. Only the researchers involved in this study and those responsible for research oversight (such as representatives of the UCSB Human Subjects Committee) will have access to any information that could identify you/that you provide. Your responses will be numbered and the code linking your number with your name will be stored in a separate file. When we publish any results from this study we will do so in a way that does not identify you. We may also share the data with other researchers so that they can check the accuracy of our conclusions, but will only do so if we are confident that your confidentiality is protected. The researcher will not know your name, and no identifying information will be connected to your survey answers in any way. The survey is therefore anonymous. However, your account is associated with an online experiment platform id that the researcher has to be able to see in order to pay you, and in some cases these numbers are associated with public profiles which could, in theory, be searched. For this reason, though the researcher will not be looking at anyone\'s public profiles, the fact of your participation in the research (as opposed to your actual survey responses) is technically considered "confidential" rather than truly anonymous.</p>' +
            '<p><b>Voluntary Participation:</b> Your participation in this study is voluntary. You are free to decline to participate, to end your participation at any time for any reason, or to refuse to answer any individual question without penalty.</p>' +
            '<p><b>Questions:</b> If you have any questions about this study, you may contact the research associate who is in charge of this research study. You can reach out by sending email to psych-yeslab.study@ucsb.edu. If you have any questions regarding your rights and participation as a research subject, please contact the Human Subjects Committee at (805) 893-3807 or hsc@research.ucsb.edu, or write to the University of California, Human Subjects Committee, Office of Research, Santa Barbara, CA 93106-2050</p>' +
            '<div style="margin-top: 40px; text-align: center;">' +
            '<p style="font-size: 18px; font-weight: bold;">Do you consent to participate in this study?</p>' +
            '<div style="display: flex; justify-content: center; gap: 40px; margin-top: 30px;">' +
            '<button class="familiarity-button" style="padding: 20px 60px; font-size: 18px;" data-response="agree">I agree</button>' +
            '<button class="familiarity-button" style="padding: 20px 60px; font-size: 18px;" data-response="disagree">I do not agree</button>' +
            '</div>' +
            '<input type="hidden" id="consent-response" value="">' +
            '</div>' +
            '</div>',
        choices: "NO_KEYS",
        data: {
            task: 'consent'
        },
        on_load: function() {
            const trialObj = this;
            trialObj.consentResponse = null;
            
            const buttons = document.querySelectorAll('[data-response]');
            const responseInput = document.getElementById('consent-response');
            
            buttons.forEach(button => {
                button.addEventListener('click', function() {
                    const response = this.getAttribute('data-response');
                    responseInput.value = response;
                    trialObj.consentResponse = response;
                    jsPsych.finishTrial();
                });
            });
        },
        on_finish: function(data) {
            data.consent_given = this.consentResponse;
            data.consented = this.consentResponse === 'agree';
        }
    };
    timeline.push(consent);
    
    // End experiment if consent not given
    const no_consent_end = {
        timeline: [{
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div style="max-width: 600px; margin: 100px auto; text-align: center;">' +
                '<h2>Thank You</h2>' +
                '<p style="font-size: 18px; margin: 40px 0;">You have chosen not to participate in this study.</p>' +
                '<p style="font-size: 16px;">If you have any questions, please contact the researcher at psych-yeslab.study@ucsb.edu.</p>' +
                '<p style="font-size: 16px; margin-top: 40px;">You may close this window.</p>' +
                '</div>',
            choices: "NO_KEYS",
            data: {
                task: 'no_consent_end'
            }
        }],
        conditional_function: function() {
            const last_trial = jsPsych.data.get().last(1).values()[0];
            return !last_trial.consented;
        }
    };
    timeline.push(no_consent_end);
    
    // Eligibility check
    const eligibility_check = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '<div style="max-width: 600px; margin: 100px auto; text-align: center;">' +
            '<h2>Eligibility Question</h2>' +
            '<p style="font-size: 18px; margin: 40px 0;">At present, do you have the legal right to vote in the U.S.?</p>' +
            '<div style="display: flex; justify-content: center; gap: 40px; margin-top: 40px;">' +
            '<button class="familiarity-button" style="padding: 20px 60px; font-size: 18px;" data-response="yes">Yes</button>' +
            '<button class="familiarity-button" style="padding: 20px 60px; font-size: 18px;" data-response="no">No</button>' +
            '</div>' +
            '<input type="hidden" id="eligibility-response" value="">' +
            '</div>',
        choices: "NO_KEYS",
        data: {
            task: 'eligibility_check'
        },
        on_load: function() {
            const trialObj = this;
            trialObj.eligibilityResponse = null;
            
            const buttons = document.querySelectorAll('[data-response]');
            const responseInput = document.getElementById('eligibility-response');
            
            buttons.forEach(button => {
                button.addEventListener('click', function() {
                    const response = this.getAttribute('data-response');
                    responseInput.value = response;
                    trialObj.eligibilityResponse = response;
                    jsPsych.finishTrial();
                });
            });
        },
        on_finish: function(data) {
            data.eligible = this.eligibilityResponse;
            data.voting_eligible = this.eligibilityResponse === 'yes';
        }
    };
    timeline.push(eligibility_check);
    
    // End experiment if not eligible
    const ineligible_end = {
        timeline: [{
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div style="max-width: 600px; margin: 100px auto; text-align: center;">' +
                '<h2>Thank You</h2>' +
                '<p style="font-size: 18px; margin: 40px 0;">Thank you for your interest in this study.</p>' +
                '<p style="font-size: 18px;">Unfortunately, this study is only open to individuals who have the legal right to vote in the U.S.</p>' +
                '<p style="font-size: 16px; margin-top: 40px;">If you have any questions, please contact the researcher at psych-yeslab.study@ucsb.edu.</p>' +
                '<p style="font-size: 16px; margin-top: 40px;">You may close this window.</p>' +
                '</div>',
            choices: "NO_KEYS",
            data: {
                task: 'ineligible_end'
            }
        }],
        conditional_function: function() {
            const last_trial = jsPsych.data.get().last(1).values()[0];
            return !last_trial.voting_eligible;
        }
    };
    timeline.push(ineligible_end);
    
    // Instructions (only shown if eligible and consented)
    const instructions = {
        timeline: [{
            type: jsPsychInstructions,
            pages: [
                '<h2>Task Structure</h2>' +
                '<p>The task consists of 2 blocks, each with different questions.</p>' +
                '<p>In each block, you will see multiple political candidates and rate them on multiple questions.</p>' +
                '<p>There are three types of trials:</p>' +
                '<ul style="text-align: left; max-width: 500px; margin: 20px auto;">' +
                '<li><b>Photo trials:</b> You will make judgments based solely on their profile photos</li>' +
                '<li><b>Bio trials:</b> You will make judgments based solely on their biographies</li>' +
                '<li><b>Dual trials:</b> You will make judgments based on both their photos and biographies</li>' +
                '</ul>' +
                '<p>Press the Next button to continue.</p>',
                
                '<h2>How to Respond</h2>' +
                '<p>After viewing the photo and/or biography for an amount of time, the rating scale will <b>appear</b> at the bottom of the screen.</p>' +
                '<p>You will see \"Now you can respond\" in the top left corner when you can start answering.</p>' +
                '<p></p>' +
                '<p><b>To enter your responses:</b></p>' +
                '<p>• For familiarity, click on the button that matches your answer. You can change your answer by clicking a different button.</p>' +
                '<p>• For other ratings, use your mouse or trackpad to move the <b>sliders</b> to indicate your ratings</p>' +
                '<p>• You can adjust your ratings before submitting</p>' +
                '<p>• Press <b>SPACEBAR</b> to submit your answers</p>' +
                '<p><b>Important:</b> Please do your best to make quick and legitimate responses, or you will see a warning.</p>' +
                '<p>There will be occasional <b>attention check questions</b> and <b>memory check questions</b> - please read carefully!</p>' +
                '<p><b>At the end of each block,</b> you will be asked to briefly explain your judgment for a few randomly selected candidates.</p>' +
                '<p>Press the Next button to begin.</p>'
            ],
            show_clickable_nav: true
        }],
        conditional_function: function() {
            const last_trials = jsPsych.data.get().last(4).values();
            // Find the eligibility trial and consent trial
            const eligibilityTrial = last_trials.find(t => t.task === 'eligibility_check');
            const consentTrial = last_trials.find(t => t.task === 'consent');
            return eligibilityTrial && eligibilityTrial.voting_eligible && consentTrial && consentTrial.consented;
        }
    };
    timeline.push(instructions);

    // Function to format candidate name from filename format to display format
    function formatCandidateName(name) {
        // Convert "Adam_Frisch" to "Adam Frisch"
        return name.replace(/_/g, ' ');
    }
    
    // Function to load bio text
    async function loadBioText(bioPath) {
        try {
            const response = await fetch(bioPath);
            const text = await response.text();
            return text;
        } catch (error) {
            console.error('Error loading bio:', error);
            return 'Bio text not available';
        }
    }

    // Function to create a rating trial
    function createRatingTrial(stimulus, question, block_num) {
        const trial_type = stimulus.type;
        const presentation_time = TEST_MODE ? 0 : (trial_type === 'photo' ? 2000 : 10000);
        const response_time_limit = trial_type === 'photo' ? 20000 : 120000;
        
        let trial_sequence = [];
        
        // Add fixation cross before each trial
        const fixation = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div class="fixation">+</div>',
            choices: "NO_KEYS",
            trial_duration: 500,
            data: {
                task: 'fixation',
                block: block_num
            }
        };
        trial_sequence.push(fixation);
        
        // Format candidate name for display
        const candidateName = formatCandidateName(stimulus.name);
        
        // Prepare stimulus content based on trial type
        let stimulusContent = '';
        if (trial_type === 'photo') {
            stimulusContent = '<img src="' + stimulus.image + '" class="stimulus-image">' +
                '<div class="candidate-name">' + candidateName + '</div>';
        } else if (trial_type === 'bio') {
            const bioText = loadedBios[stimulus.name] || 'Bio text not available';
            stimulusContent = '<div class="bio-text">' + bioText.replace(/\n/g, '<br>') + '</div>';
        } else if (trial_type === 'dual') {
            const bioText = loadedBios[stimulus.name] || 'Bio text not available';
            stimulusContent = '<div class="dual-container">' +
                '<img src="' + stimulus.image + '" class="stimulus-image">' +
                '<div class="candidate-name">' + candidateName + '</div>' +
                '<div class="bio-text">' + bioText.replace(/\n/g, '<br>') + '</div>' +
                '</div>';
        }
        
        // Combined stimulus + rating trial (presentation only, no sliders yet)
        const combined_trial = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div class="stimulus-with-rating">' +
                '<div id="warning-container"></div>' +
                '<div class="stimulus-content">' +
                stimulusContent +
                '</div>' +
                '</div>',
            choices: "NO_KEYS",
            trial_duration: presentation_time,
            data: {
                task: 'stimulus_presentation',
                stimulus_name: stimulus.name,
                stimulus_trial_type: stimulus.type,
                block: block_num,
                question: question.text
            }
        };
        trial_sequence.push(combined_trial);
        
        // Rating response phase with sliders
        const rating_selection = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
                // Only show familiarity question in first block (block_num === 1)
                let familiarityHTML = '';
                if (block_num === 1) {
                    familiarityHTML = '<div class="question-text" style="margin-top: 30px;">Before participating, how familiar were you with this person?</div>' +
                        '<div class="familiarity-buttons">' +
                        '<button class="familiarity-button" data-value="0">I do not know anything about this person</button>' +
                        '<button class="familiarity-button" data-value="1">I know who this person is or have heard about them</button>' +
                        '</div>' +
                        '<input type="hidden" id="familiarity-value" value="">';
                }
                
                // Check if we need to show confidence question (block 1 only)
                let confidenceQuestionHTML = '';
                if (question.confidenceQuestion) {
                    confidenceQuestionHTML = '<div class="question-text" style="margin-top: 40px;">' + question.confidenceQuestion.text + '</div>' +
                        '<div class="slider-wrapper">' +
                        '<input type="range" min="1" max="7" value="4" class="slider" id="confidence-slider">' +
                        '<span class="slider-value" id="confidence-value">4</span>' +
                        '</div>' +
                        '<div class="slider-labels">' +
                        '<span>' + question.confidenceQuestion.scale_labels[0] + '</span>' +
                        '<span>' + question.confidenceQuestion.scale_labels[1] + '</span>' +
                        '</div>';
                }
                
                // Secondary question removed from both blocks
                let secondaryQuestionHTML = '';
                
                // Use different slider IDs based on block
                const mainSliderId = block_num === 1 ? 'competence-slider' : 'vote-slider';
                const mainValueId = block_num === 1 ? 'competence-value' : 'vote-value';
                
                return '<div class="stimulus-with-rating">' +
                    '<div class="response-indicator">Now you can respond</div>' +
                    '<div id="warning-container"></div>' +
                    stimulusContent +
                    '<div class="slider-container">' +
                    familiarityHTML +
                    '<div class="question-text" style="margin-top: 40px;">' + question.text + '</div>' +
                    '<div class="slider-wrapper">' +
                    '<input type="range" min="1" max="7" value="4" class="slider" id="' + mainSliderId + '">' +
                    '<span class="slider-value" id="' + mainValueId + '">4</span>' +
                    '</div>' +
                    '<div class="slider-labels">' +
                    '<span>' + question.scale_labels[0] + '</span>' +
                    '<span>' + question.scale_labels[1] + '</span>' +
                    '</div>' +
                    confidenceQuestionHTML +
                    secondaryQuestionHTML +
                    '<div class="submit-prompt" id="submit-prompt" style="margin-top: 30px; font-size: 16px; font-style: italic;">Press SPACEBAR to submit your answers</div>' +
                    '</div>' +
                    '</div>';
            },
            choices: "NO_KEYS",
            data: {
                task: 'rating',
                stimulus_name: stimulus.name,
                stimulus_trial_type: stimulus.type,
                block: block_num,
                question: question.text,
                secondary_question: question.secondaryQuestion ? question.secondaryQuestion.text : null
            },
            on_load: function() {
                // Store current values on the trial object so they persist after DOM is cleared
                const trialObj = this;
                trialObj.currentFamiliarity = null;
                trialObj.currentCompetenceRating = '4';  // default slider value for block 1
                trialObj.currentVoteRating = '4';  // default slider value for block 2
                trialObj.currentConfidenceRating = '4';  // default slider value
                trialObj.currentSecondaryRating = '4';  // default slider value
                
                // Track whether user actually interacted with controls
                trialObj.familiarityClicked = false;
                trialObj.competenceSliderMoved = false;
                trialObj.voteSliderMoved = false;
                trialObj.confidenceSliderMoved = false;
                trialObj.secondarySliderMoved = false;
                
                // Get slider elements based on block
                const familiarityButtons = document.querySelectorAll('.familiarity-button');
                const familiarityValue = document.getElementById('familiarity-value');
                const mainSlider = block_num === 1 ? document.getElementById('competence-slider') : document.getElementById('vote-slider');
                const mainValue = block_num === 1 ? document.getElementById('competence-value') : document.getElementById('vote-value');
                const confidenceSlider = document.getElementById('confidence-slider');
                const confidenceValue = document.getElementById('confidence-value');
                const secondarySlider = document.getElementById('secondary-slider');
                const secondaryValue = document.getElementById('secondary-value');
                
                // Handle familiarity button clicks
                if (familiarityButtons.length > 0 && familiarityValue) {
                    familiarityButtons.forEach(button => {
                        button.addEventListener('click', function() {
                            // Remove selected class from all buttons
                            familiarityButtons.forEach(btn => btn.classList.remove('selected'));
                            // Add selected class to clicked button
                            this.classList.add('selected');
                            // Update hidden input value
                            const value = this.getAttribute('data-value');
                            familiarityValue.value = value;
                            // Store in trial object
                            trialObj.currentFamiliarity = value;
                            trialObj.familiarityClicked = true;
                        });
                    });
                }
                
                // Update display when sliders change
                if (mainSlider && mainValue) {
                    mainSlider.oninput = function() {
                        mainValue.textContent = this.value;
                        // Store in trial object based on block
                        if (block_num === 1) {
                            trialObj.currentCompetenceRating = this.value;
                            trialObj.competenceSliderMoved = true;
                        } else {
                            trialObj.currentVoteRating = this.value;
                            trialObj.voteSliderMoved = true;
                        }
                    };
                }
                
                if (confidenceSlider && confidenceValue) {
                    confidenceSlider.oninput = function() {
                        confidenceValue.textContent = this.value;
                        // Store in trial object
                        trialObj.currentConfidenceRating = this.value;
                        trialObj.confidenceSliderMoved = true;
                    };
                }
                
                if (secondarySlider && secondaryValue) {
                    secondarySlider.oninput = function() {
                        secondaryValue.textContent = this.value;
                        // Store in trial object
                        trialObj.currentSecondaryRating = this.value;
                        trialObj.secondarySliderMoved = true;
                    };
                }
                
                // Record when the participant was allowed to respond (for RT calculation)
                trialObj.responseStartTime = performance.now();

                // Add spacebar handler with validation
                const spacebarHandler = function(e) {
                    if (e.key === ' ' || e.code === 'Space') {
                        e.preventDefault();
                        
                        // Validate responses
                        let validationErrors = [];
                        
                        // Check familiarity (only in block 1)
                        if (block_num === 1 && !trialObj.familiarityClicked) {
                            validationErrors.push('Please select your familiarity with this person');
                        }
                        
                        // Check main slider based on block
                        const sliderMoved = block_num === 1 ? trialObj.competenceSliderMoved : trialObj.voteSliderMoved;
                        const sliderName = block_num === 1 ? 'competence rating' : 'vote intention';
                        if (!sliderMoved) {
                            validationErrors.push('Please move the ' + sliderName + ' slider. If your answer is neutral, please move the slider back to the center');
                        }
                        
                        // Check confidence slider (only if it exists)
                        if (confidenceSlider && !trialObj.confidenceSliderMoved) {
                            validationErrors.push('<br>Please move the confidence rating slider. If your answer is neutral, please move the slider back to the center');
                        }
                        
                        // Check secondary slider (only if it exists)
                        if (secondarySlider && !trialObj.secondarySliderMoved) {
                            validationErrors.push('<br>Please move the secondary rating slider. If your answer is neutral, please move the slider back to the center');
                        }
                        
                        // If validation fails, show warning
                        if (validationErrors.length > 0) {
                            const warningDiv = document.getElementById('warning-container');
                            if (warningDiv) {
                                warningDiv.innerHTML = '<div class="validation-warning">' + validationErrors.join('. ') + '.</div>';
                                // Clear validation warning after 3 seconds
                                setTimeout(function() {
                                    if (warningDiv) {
                                        warningDiv.innerHTML = '';
                                    }
                                }, 3000);
                            }
                            return; // Don't proceed
                        }
                        
                        // If validation passes, end trial with data
                        document.removeEventListener('keydown', spacebarHandler);
                        
                        // Create data object to pass to finishTrial (include plugin metadata and computed RT)
                        const trialData = {
                            task: 'rating',
                            stimulus_name: stimulus.name,
                            stimulus_trial_type: stimulus.type,
                            block: block_num,
                            familiarity_response: trialObj.currentFamiliarity,
                            familiarity_clicked: trialObj.familiarityClicked,
                            confidence_response: confidenceSlider ? trialObj.currentConfidenceRating : null,
                            competence_slider_moved: block_num === 1 ? trialObj.competenceSliderMoved : null,
                            vote_slider_moved: block_num === 2 ? trialObj.voteSliderMoved : null,
                            confidence_slider_moved: trialObj.confidenceSliderMoved,
                            // compute RT since finishTrial is called programmatically
                            rt: Math.round(performance.now() - trialObj.responseStartTime)
                        };
                        // Set competence_response or vote_response based on block
                        if (block_num === 1) {
                            trialData.competence_response = trialObj.currentCompetenceRating;
                        } else {
                            trialData.vote_response = trialObj.currentVoteRating;
                        }
                        
                        console.log('Submitting rating trial data:', trialData);
                        jsPsych.finishTrial(trialData);
                    }
                };
                document.addEventListener('keydown', spacebarHandler);
                
                // Show warning after response_time_limit
                const warningTimeout = setTimeout(function() {
                    const warningDiv = document.getElementById('warning-container');
                    if (warningDiv && jsPsych.getCurrentTrial().type !== null) {
                        warningDiv.innerHTML = '<div class="warning-message">Please respond faster!</div>';
                    }
                }, response_time_limit);
                
                // Store timeout and handler for cleanup
                this.warningTimeout = warningTimeout;
                this.spacebarHandler = spacebarHandler;
            },
            on_finish: function(data) {
                // Data is now passed from finishTrial, but also set from trial object as backup
                // Use 'in' checks to allow '0' and other falsy values
                if (!('familiarity_response' in data) || data.familiarity_response === null) {
                    data.familiarity_response = this.currentFamiliarity;
                }
                // Set competence_response or vote_response based on block
                if (block_num === 1) {
                    if (!('competence_response' in data) || data.competence_response === null) {
                        data.competence_response = this.currentCompetenceRating;
                    }
                } else {
                    if (!('vote_response' in data) || data.vote_response === null) {
                        data.vote_response = this.currentVoteRating;
                    }
                }
                if (!('confidence_response' in data) || data.confidence_response === null) {
                    data.confidence_response = this.currentConfidenceRating;
                }

                // Debug: log rating data for each rating trial (helps verify ratings are recorded)
                console.log('Rating trial data:', {
                    stimulus_name: data.stimulus_name,
                    block: data.block,
                    familiarity_response: data.familiarity_response,
                    competence_response: data.competence_response,
                    vote_response: data.vote_response,
                    confidence_response: data.confidence_response,
                    rt: data.rt
                });
                
                data.responded_on_time = data.rt !== null && data.rt <= response_time_limit;
                data.reaction_time_ms = data.rt;
                data.response_time_limit_ms = response_time_limit;
                
                // Store rating for free writing component
                const blockKey = 'block' + block_num;
                candidateRatings[blockKey][stimulus.name] = {
                    name: stimulus.name,
                    trial_type: stimulus.type,
                    image: stimulus.image,
                    response: block_num === 1 ? data.competence_response : data.vote_response,
                    question_type: block_num === 1 ? 'competence' : 'vote'
                };
                
                // Track familiar candidates in block 1 to exclude from later blocks
                if (block_num === 1 && data.familiarity_response === '1') {
                    familiarCandidates.push(stimulus.name);
                    console.log('Added familiar candidate:', stimulus.name, '- Total familiar:', familiarCandidates.length);
                }
                
                // Clean up timeout and event listener
                if (this.warningTimeout) {
                    clearTimeout(this.warningTimeout);
                }
                if (this.spacebarHandler) {
                    document.removeEventListener('keydown', this.spacebarHandler);
                }
            }
        };
        trial_sequence.push(rating_selection);
        
        return {
            timeline: trial_sequence
        };
    }

    // Function to create attention check trial
    function createAttentionCheck(correct_key, block_num) {
        // Fixation before attention check
        const fixation = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div class="fixation">+</div>',
            choices: "NO_KEYS",
            trial_duration: 500,
            data: {
                task: 'fixation',
                block: block_num
            }
        };
        
        const attention_trial = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div class="attention-check">' +
                '<p><b>Attention Check:</b></p>' +
                '<p>To ensure you are paying attention, please press the number <b>' + correct_key + '</b> on your keyboard.</p>' +
                '</div>',
            choices: ['1', '2', '3', '4', '5', '6', '7'],
            data: {
                task: 'attention_check',
                attention_check_question: 'Press the number ' + correct_key,
                attention_check_correct_key: correct_key,
                block: block_num,
                stimulus_name: null,
                stimulus_trial_type: null
            },
            on_finish: function(data) {
                data.attention_check_response = data.response;
                data.attention_check_correct = data.response === correct_key;
                data.correct = data.response === correct_key;
                data.reaction_time_ms = data.rt;
                // Debug: print correct key and response
                console.log('Attention Check - Correct key:', correct_key, 'Response:', data.response, 'Correct?:', data.correct);
            }
        };
        
        const feedback = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
                const last_trial = jsPsych.data.get().last(1).values()[0];
                if (!last_trial.correct) {
                    return '<div style="display: flex; justify-content: center; align-items: center; height: 100vh;">' +
                        '<div class="warning-message">Wrong answer! Please pay attention to the task.</div>' +
                        '</div>';
                }
                return '';
            },
            choices: "NO_KEYS",
            trial_duration: function() {
                const last_trial = jsPsych.data.get().last(1).values()[0];
                return last_trial.correct ? 0 : 2000;
            },
            data: {
                task: 'attention_check_feedback',
                block: block_num
            }
        };
        
        return {
            timeline: [fixation, attention_trial, feedback]
        };
    }

    // Function to create memory check trial
    function createMemoryCheck(stimulus, block_num) {
        // Fixation before memory check
        const fixation = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div class="fixation">+</div>',
            choices: "NO_KEYS",
            trial_duration: 500,
            data: {
                task: 'fixation',
                block: block_num
            }
        };
        
        const memory_trial = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div class="attention-check">' +
                '<p><b>Memory Check:</b></p>' +
                '<p>' + stimulus.check_question + '</p>' +
                '<div style="margin-top: 30px; display: flex; justify-content: center; gap: 40px;">' +
                '<button class="familiarity-button" style="padding: 20px 60px; font-size: 18px;" data-response="1">Yes</button>' +
                '<button class="familiarity-button" style="padding: 20px 60px; font-size: 18px;" data-response="0">No</button>' +
                '</div>' +
                '<input type="hidden" id="memory-response" value="">' +
                '</div>',
            choices: "NO_KEYS",
            trial_duration: 10000,
            data: {
                task: 'memory_check',
                stimulus_name: stimulus.name,
                stimulus_trial_type: stimulus.type,
                memory_check_question: stimulus.check_question,
                memory_check_correct_answer: stimulus.check_answer,
                block: block_num
            },
            on_load: function() {
                // Store response on trial object
                const trialObj = this;
                trialObj.memoryResponse = null;
                
                const buttons = document.querySelectorAll('[data-response]');
                const responseInput = document.getElementById('memory-response');
                
                buttons.forEach(button => {
                    button.addEventListener('click', function() {
                        const response = this.getAttribute('data-response');
                        responseInput.value = response;
                        // Store in trial object
                        trialObj.memoryResponse = response;
                        jsPsych.finishTrial();
                    });
                });
            },
            on_finish: function(data) {
                // Get response from trial object
                data.memory_check_response = this.memoryResponse;
                // Convert to strings for comparison since CSV values are strings
                data.memory_check_correct = data.memory_check_response === String(data.memory_check_correct_answer);
                data.memory_check_timed_out = data.memory_check_response === null || data.memory_check_response === '';
                data.reaction_time_ms = data.rt;
                console.log('Memory check - Question:', stimulus.check_question, 
                           '| Response:', data.memory_check_response, '| Correct answer:', data.memory_check_correct_answer, 
                           '| Is correct:', data.memory_check_correct);
            }
        };
        
        const feedback = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
                const last_trial = jsPsych.data.get().last(1).values()[0];
                if (last_trial.memory_check_timed_out) {
                    return '<div style="display: flex; justify-content: center; align-items: center; height: 100vh;">' +
                        '<div style="color: red; font-size: 18px; font-weight: bold; text-align: center;">Too slow! Please respond faster to memory check questions.</div>' +
                        '</div>';
                } else if (!last_trial.memory_check_correct) {
                    return '<div style="display: flex; justify-content: center; align-items: center; height: 100vh;">' +
                        '<div style="color: red; font-size: 18px; font-weight: bold; text-align: center;">Wrong answer! Please pay attention to the biography content.</div>' +
                        '</div>';
                } else {
                    return '<div style="display: flex; justify-content: center; align-items: center; height: 100vh;">' +
                        '<div style="color: green; font-size: 18px; font-weight: bold; text-align: center;">Your answer is correct. Great job paying attention!</div>' +
                        '</div>';
                }
            },
            choices: "NO_KEYS",
            trial_duration: function() {
                const last_trial = jsPsych.data.get().last(1).values()[0];
                return (last_trial.memory_check_timed_out || !last_trial.memory_check_correct) ? 2000 : 1500;
            },
            data: {
                task: 'memory_check_feedback',
                block: block_num
            }
        };
        
        return {
            timeline: [fixation, memory_trial, feedback]
        };
    }

    // Function to create free writing trials for a block
    function createFreeWritingTrials(block_num) {
        const blockKey = 'block' + block_num;
        const ratings = candidateRatings[blockKey];
        
        // Filter based on block: block 1 = competence, block 2 = vote
        const questionType = block_num === 1 ? 'competence' : 'vote';
        const filteredRatings = Object.values(ratings).filter(r => r.question_type === questionType);
        
        // Group by trial type
        const photoRatings = filteredRatings.filter(r => r.trial_type === 'photo');
        const bioRatings = filteredRatings.filter(r => r.trial_type === 'bio');
        const dualRatings = filteredRatings.filter(r => r.trial_type === 'dual');
        
        console.log('Free writing - Block', block_num, questionType, 'candidates:', {
            photo: photoRatings.length,
            bio: bioRatings.length,
            dual: dualRatings.length
        });
        
        // Select one candidate from each condition
        const selectedCandidates = [];
        if (photoRatings.length > 0) {
            selectedCandidates.push(jsPsych.randomization.sampleWithoutReplacement(photoRatings, 1)[0]);
        }
        if (bioRatings.length > 0) {
            selectedCandidates.push(jsPsych.randomization.sampleWithoutReplacement(bioRatings, 1)[0]);
        }
        if (dualRatings.length > 0) {
            selectedCandidates.push(jsPsych.randomization.sampleWithoutReplacement(dualRatings, 1)[0]);
        }
        
        console.log('Selected candidates for free writing:', selectedCandidates.map(c => c.name + ' (' + c.trial_type + ')'));
        
        // Add introduction screen
        const introScreen = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div style="max-width: 700px; margin: 100px auto; text-align: center;">' +
                '<h2>Free Response Section</h2>' +
                '<p style="font-size: 18px; margin: 30px 0;">You will now be asked to briefly explain your judgment for ' + selectedCandidates.length + ' randomly selected candidates from Block ' + block_num + '.</p>' +
                '<p style="font-size: 16px;">Please provide a brief explanation of how you formed your opinion.</p>' +
                '<p style="font-size: 16px; margin-top: 30px;">Press the spacebar to continue.</p>' +
                '</div>',
            choices: [' '],
            data: {
                task: 'free_writing_intro',
                block: block_num
            }
        };
        
        // Create trials for each selected candidate
        const freeWritingTrials = [introScreen];
        
        for (let candidate of selectedCandidates) {
            const candidateName = formatCandidateName(candidate.name);
            
            // Display candidate info based on trial type (show original trial information)
            let candidateDisplay = '';
            if (candidate.trial_type === 'photo') {
                candidateDisplay = '<img src="' + candidate.image + '" class="stimulus-image">' +
                    '<div class="candidate-name">' + candidateName + '</div>';
            } else if (candidate.trial_type === 'bio') {
                const bioText = loadedBios[candidate.name] || 'Bio text not available';
                candidateDisplay = '<div class="bio-text">' + bioText.replace(/\n/g, '<br>') + '</div>';
            } else if (candidate.trial_type === 'dual') {
                const bioText = loadedBios[candidate.name] || 'Bio text not available';
                candidateDisplay = '<div class="dual-container">' +
                    '<img src="' + candidate.image + '" class="stimulus-image">' +
                    '<div class="candidate-name">' + candidateName + '</div>' +
                    '<div class="bio-text">' + bioText.replace(/\n/g, '<br>') + '</div>' +
                    '</div>';
            }
            
            // Create trial
            const freeWritingTrial = {
                type: jsPsychHtmlKeyboardResponse,
                stimulus: function() {
                    // Determine question text based on block
                    const questionText = block_num === 1 
                        ? 'How good do you think this person would be as a member of congress?'
                        : 'In general, how likely would you be to vote for this person as a U.S. House Representative?';
                    
                    return '<div class="free-writing-container">' +
                        '<div id="validation-message" class="validation-warning" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; display: none;"></div>' +
                        candidateDisplay +
                        '<div class="rating-display">' +
                        '<em>Question: ' + questionText + '</em><br>' +
                        'Your rating: <strong>' + candidate.response + '</strong> out of 7<br>' +
                        '</div>' +
                        '<div class="free-writing-prompt">Please briefly explain how you made your judgment/decision:</div>' +
                        '<textarea class="free-writing-textarea" id="free-response" placeholder="Type your explanation here..."></textarea>' +
                        '<button id="submit-button" class="familiarity-button" style="margin-top: 20px; padding: 15px 40px; font-size: 16px;">Submit</button>' +
                        '</div>';
                },
                choices: "NO_KEYS",
                data: {
                    task: 'free_writing',
                    stimulus_name: candidate.name,
                    stimulus_trial_type: candidate.trial_type,
                    block: block_num,
                    competence_response: candidate.question_type === 'competence' ? candidate.response : null,
                    vote_response: candidate.question_type === 'vote' ? candidate.response : null
                },
                on_load: function() {
                    const trialObj = this;
                    const textarea = document.getElementById('free-response');
                    const validationMessage = document.getElementById('validation-message');
                    const submitButton = document.getElementById('submit-button');
                    
                    const submitHandler = function() {
                        const response = textarea.value.trim();
                        
                        // Validate that something was written (at least 10 characters)
                        if (response.length < 10) {
                            validationMessage.textContent = 'Please provide a more detailed explanation.';
                            validationMessage.style.display = 'block';
                            return;
                        }
                        
                        // If valid, end trial
                        submitButton.removeEventListener('click', submitHandler);
                        jsPsych.finishTrial({
                            free_response: response,
                            response_length: response.length
                        });
                    };
                    
                    // Clear validation message when user starts typing
                    textarea.addEventListener('input', function() {
                        if (validationMessage) {
                            validationMessage.textContent = '';
                            validationMessage.style.display = 'none';
                        }
                    });
                    
                    submitButton.addEventListener('click', submitHandler);
                    trialObj.submitHandler = submitHandler;
                },
                on_finish: function(data) {
                    data.reaction_time_ms = data.rt;
                    console.log('Free writing response:', {
                        candidate: data.stimulus_name,
                        competence_response: data.competence_response,
                        vote_response: data.vote_response,
                        response_length: data.response_length
                    });
                    
                    // Clean up event listener
                    if (this.submitHandler) {
                        const submitButton = document.getElementById('submit-button');
                        if (submitButton) {
                            submitButton.removeEventListener('click', this.submitHandler);
                        }
                    }
                }
            };
            
            freeWritingTrials.push(freeWritingTrial);
        }
        
        return freeWritingTrials;
    }

    // Function to build a single block
    function buildBlock(block, pushToTimeline = true) {
        // Block instructions
        let instructionText = '<h2>Block ' + (block + 1) + ' of 2</h2>';
        
        if (block === 0) {
            // Block 1: mention familiarity, main question, and confidence
            instructionText += '<p>For this block, you will answer the following questions:</p>' +
                '<p style="font-size: 18px; font-weight: bold; margin: 20px;">1. Familiarity: Before participating, how familiar were you with this person?</p>' +
                '<p style="font-size: 18px; font-weight: bold; margin: 20px;">2. ' + questions[block].text + '</p>' +
                '<p style="font-size: 18px; font-weight: bold; margin: 20px;">3. ' + questions[block].confidenceQuestion.text + '</p>' +
                '<p>Press the spacebar to begin.</p>';
        } else {
            // Block 2: show only main question (vote intention)
            instructionText += '<p>For this block, you will answer the following question:</p>' +
                '<p style="font-size: 18px; font-weight: bold; margin: 20px;">' + questions[block].text + '</p>' +
                '<p>Press the spacebar to begin.</p>';
        }
        
        const block_instructions = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: instructionText,
            choices: [' ']
        };
        
        // Create a local timeline for this block
        const blockTimeline = [];
        blockTimeline.push(block_instructions);
        
        // Filter stimuli based on block
        let available_stimuli;
        if (block === 0) {
            // Block 1: use all stimuli
            available_stimuli = [...stimuli];
            console.log('Block 1: Using all', available_stimuli.length, 'stimuli');
        } else {
            // Block 2: filter out familiar candidates
            console.log('Block 2: Familiar candidates to filter:', familiarCandidates);
            available_stimuli = stimuli.filter(s => !familiarCandidates.includes(s.name));
            console.log('Block 2: Filtering out', familiarCandidates.length, 'familiar candidates');
            console.log('Block 2: Using', available_stimuli.length, 'stimuli');
            console.log('Block 2: Available stimulus names:', available_stimuli.map(s => s.name));
        }
        
        // Group by trial type
        const photoTrials = jsPsych.randomization.shuffle(available_stimuli.filter(s => s.type === 'photo'));
        const bioTrials = jsPsych.randomization.shuffle(available_stimuli.filter(s => s.type === 'bio'));
        const dualTrials = jsPsych.randomization.shuffle(available_stimuli.filter(s => s.type === 'dual'));
        
        // Shuffle the order of the three groups for this block
        const trialGroups = jsPsych.randomization.shuffle([
            {name: 'photo', trials: photoTrials},
            {name: 'bio', trials: bioTrials},
            {name: 'dual', trials: dualTrials}
        ]);
        
        // Concatenate in the shuffled order
        const block_stimuli = [];
        trialGroups.forEach(group => {
            block_stimuli.push(...group.trials);
        });
        console.log('Block', block + 1, 'trial order:', trialGroups.map(g => g.name).join(' -> '));
        
        // Select bio and dual trials that have memory check questions
        const bioDualTrials = block_stimuli.filter(s => 
            (s.type === 'bio' || s.type === 'dual') && s.check_question && s.check_question.length > 0
        );
        
        // Get the memory check tracking set for this block
        const currentBlockMemorySet = block === 0 ? memoryCheckUsed.block1 : memoryCheckUsed.block2;
        
        // Filter out trials already used for memory checks in this block
        const availableForMemoryCheck = bioDualTrials.filter(s => !currentBlockMemorySet.has(s.name));
        
        // Calculate 10% (rounded up) of available bio/dual trials for memory checks
        const numMemoryChecks = Math.ceil(availableForMemoryCheck.length * 0.1);
        const memoryCheckTrials = jsPsych.randomization.sampleWithoutReplacement(availableForMemoryCheck, Math.min(numMemoryChecks, availableForMemoryCheck.length));
        
        // Mark these trials as used for memory checks in this block
        memoryCheckTrials.forEach(t => currentBlockMemorySet.add(t.name));
        
        const memoryCheckNames = new Set(memoryCheckTrials.map(t => t.name));
        
        console.log('Block', block + 1, '- Total bio/dual trials:', bioDualTrials.length, 
                    '- Available for memory check:', availableForMemoryCheck.length,
                    '- Memory checks:', memoryCheckTrials.length,
                    '- Selected:', Array.from(memoryCheckNames));
        
        // Calculate number of attention checks (10% of trials, at least 1)
        const num_attention_checks = Math.max(1, Math.round(block_stimuli.length * 0.1));
        
        // Create array of trial indices and randomly select positions for attention checks
        let trial_indices = Array.from({length: block_stimuli.length}, (_, i) => i);
        let attention_check_positions = jsPsych.randomization.sampleWithoutReplacement(trial_indices, num_attention_checks);
        
        // Add rating trials with randomly inserted attention checks
        for (let i = 0; i < block_stimuli.length; i++) {
            blockTimeline.push(createRatingTrial(block_stimuli[i], questions[block], block + 1));
            
            // Add memory check if this trial was selected for memory check
            if (memoryCheckNames.has(block_stimuli[i].name)) {
                blockTimeline.push(createMemoryCheck(block_stimuli[i], block + 1));
            }
            
            // Add attention check if this position was selected
            if (attention_check_positions.includes(i)) {
                const random_key = String(Math.floor(Math.random() * 7) + 1);
                blockTimeline.push(createAttentionCheck(random_key, block + 1));
            }
        }
        
        // Either push to main timeline or return the block timeline
        if (pushToTimeline) {
            blockTimeline.forEach(t => timeline.push(t));
        } else {
            return blockTimeline;
        }
        return blockTimeline;
    }

    // Function to build the experimental blocks
    function buildBlocks() {
        // Build Block 1
        buildBlock(0);
        
        // Add coordinator to trigger free writing for Block 1, then break screen, then Block 2
        const coordinator = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '',
            trial_duration: 0,
            choices: "NO_KEYS",
            data: {
                task: 'free_writing_coordinator',
                block: 1
            },
            on_finish: function() {
                // Add Block 1 free writing trials
                const freeWriting1 = createFreeWritingTrials(1);
                freeWriting1.forEach(t => jsPsych.addNodeToEndOfTimeline(t));
                
                // Add break screen
                jsPsych.addNodeToEndOfTimeline(break_screen);
            }
        };
        timeline.push(coordinator);
        
        // Define break screen (will be added dynamically by coordinator)
        const break_screen = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<h2>Break</h2>' +
                '<p>You have completed block 1 of 2.</p>' +
                '<p>Take a short break if needed.</p>' +
                '<p>Press the spacebar when you are ready to continue.</p>',
            choices: [' '],
            on_finish: function() {
                console.log('Block 1 complete. Familiar candidates:', familiarCandidates.length, '-', familiarCandidates);
                
                // TEST MODE: If no familiar candidates, simulate some for testing Block 2 filtering
                if (TEST_MODE && familiarCandidates.length === 0) {
                    console.log('TEST MODE: Simulating familiar candidates');
                    const testFamiliar = jsPsych.randomization.sampleWithoutReplacement(
                        stimuli.map(s => s.name), 
                        Math.min(3, stimuli.length)
                    );
                    familiarCandidates.push(...testFamiliar);
                    console.log('TEST MODE: Marked as familiar:', familiarCandidates);
                }
                
                // Build Block 2 now and add to timeline
                console.log('Building Block 2 now with familiar candidates filtered out...');
                const block2Timeline = buildBlock(1, false);

                // Insert Block 2 trials into the timeline right after this trial
                console.log('Inserting', block2Timeline.length, 'Block 2 trials after current index');

                // Add each trial from Block 2
                block2Timeline.forEach(trial => {
                    jsPsych.addNodeToEndOfTimeline(trial);
                });
                
                // Add free writing trigger for Block 2
                const freeWriting2Placeholder = {
                    type: jsPsychHtmlKeyboardResponse,
                    stimulus: '',
                    trial_duration: 0,
                    choices: "NO_KEYS",
                    data: {
                        task: 'free_writing_trigger',
                        block: 2
                    },
                    on_finish: function() {
                        // Create and add free writing trials for Block 2
                        const freeWritingTrials = createFreeWritingTrials(2);
                        freeWritingTrials.forEach(t => {
                            jsPsych.addNodeToEndOfTimeline(t);
                        });
                        
                        // After free writing, add the final screen
                        console.log('Appending final screen after Block 2 free writing');
                        jsPsych.addNodeToEndOfTimeline(final_screen);
                    }
                };
                jsPsych.addNodeToEndOfTimeline(freeWriting2Placeholder);
            }
        };
        // NOTE: break_screen is added dynamically by coordinator, not pushed here
        
        // Define final screen (will be added after Block 2 free writing completes)
        const final_screen = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<h2>Thank you!</h2>' +
                '<p>You have completed the experiment.</p>' +
                '<p>If you have any questions, please contact the researcher at psych-yeslab.study@ucsb.edu.</p>'+
                '<p>Press any key to finish. After pressing the key, please <b>wait a moment while we process your data</b>. You will be noticed when we finished and be redirected to SONA.</p>',
            choices: "ALL_KEYS"
        };
        // NOTE: final_screen is now added after Block 2 free writing completes
    }

    // Load materials, preload bios, build blocks, then run the experiment
    loadMaterials().then(() => {
        console.log('Materials loaded. Stimuli count:', stimuli.length);
        return preloadBios();
    }).then(() => {
        console.log('Bios preloaded');
        buildBlocks();
        console.log('Blocks built. Timeline length:', timeline.length);
        console.log('Starting experiment...');
        jsPsych.run(timeline);
    }).catch((error) => {
        console.error('Error during experiment setup:', error);
        alert('Error loading experiment: ' + error.message);
    });

</script>
</html>
